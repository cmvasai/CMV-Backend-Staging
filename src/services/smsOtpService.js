/**
 * SMS OTP Service using 2Factor OTP Service API (AUTOGEN3)
 * 
 * Provides SMS-based OTP functionality for phone verification
 * using 2Factor.in OTP Service with AUTOGEN3 (SMS ONLY - NO VOICE FALLBACK)
 * Uses 2Factor's default DLT-approved templates - no custom DLT registration needed
 * 
 * Features:
 * - Send OTP via SMS only (AUTOGEN3 = no voice fallback)
 * - OTP generated by 2Factor server (more secure)
 * - OTP verification via 2Factor VERIFY3 API
 * - 60-second resend cooldown
 * - 10-digit Indian phone validation
 */

const axios = require('axios');
const crypto = require('crypto');
const logger = require('../utils/logger');

class SMSOtpService {
  constructor() {
    // In-memory storage for session tracking
    // Key: phoneNumber, Value: { sessionId, lastSentAt, expiresAt, attempts }
    this.otpStore = new Map();
    
    // 2Factor API configuration
    this.apiKey = process.env.TWOFACTOR_API_KEY;
    this.baseUrl = 'https://2factor.in/API/V1';
    
    // Using AUTOGEN3 = SMS only, no voice fallback
    // Uses 2Factor's default DLT-approved template (no custom DLT needed)
    
    // Cooldown and expiry settings
    this.resendCooldownMs = 60 * 1000; // 60 seconds
    this.otpExpiryMs = 5 * 60 * 1000;  // 5 minutes
    
    // Cleanup expired entries every 10 minutes
    setInterval(() => this.cleanupExpiredEntries(), 10 * 60 * 1000);
  }

  /**
   * Generate a secure 6-digit OTP
   * @returns {string} - 6-digit OTP
   */
  generateOTP() {
    // Generate cryptographically secure 6-digit OTP
    return crypto.randomInt(100000, 999999).toString();
  }

  /**
   * Validate 10-digit Indian phone number
   * @param {string} phoneNumber - Phone number to validate
   * @returns {boolean} - Whether the phone number is valid
   */
  validatePhoneNumber(phoneNumber) {
    if (!phoneNumber || typeof phoneNumber !== 'string') {
      return false;
    }
    
    // Remove any spaces, dashes, or country code prefix
    const cleanedNumber = phoneNumber.replace(/[\s\-]/g, '').replace(/^\+91/, '');
    
    // Must be exactly 10 digits and start with 6, 7, 8, or 9
    const phoneRegex = /^[6-9]\d{9}$/;
    return phoneRegex.test(cleanedNumber);
  }

  /**
   * Clean phone number to standard format (10 digits)
   * @param {string} phoneNumber - Phone number to clean
   * @returns {string} - Cleaned 10-digit phone number
   */
  cleanPhoneNumber(phoneNumber) {
    return phoneNumber.replace(/[\s\-]/g, '').replace(/^\+91/, '');
  }

  /**
   * Check if OTP can be resent (60-second cooldown)
   * @param {string} phoneNumber - Phone number to check
   * @returns {Object} - { canResend: boolean, remainingSeconds: number }
   */
  canResend(phoneNumber) {
    const cleanedPhone = this.cleanPhoneNumber(phoneNumber);
    const stored = this.otpStore.get(cleanedPhone);
    
    if (!stored || !stored.lastSentAt) {
      return { canResend: true, remainingSeconds: 0 };
    }
    
    const elapsed = Date.now() - stored.lastSentAt;
    const remaining = this.resendCooldownMs - elapsed;
    
    if (remaining <= 0) {
      return { canResend: true, remainingSeconds: 0 };
    }
    
    return { canResend: false, remainingSeconds: Math.ceil(remaining / 1000) };
  }

  /**
   * Send OTP to phone number via 2Factor Transactional SMS API (SMS ONLY)
   * @param {string} phoneNumber - 10-digit Indian phone number
   * @returns {Promise<Object>} - { success: boolean, message: string }
   */
  async sendOTP(phoneNumber) {
    try {
      // Validate API key
      if (!this.apiKey) {
        logger.error('2Factor API key not configured');
        return {
          success: false,
          message: 'SMS service not configured. Please contact support.'
        };
      }

      // Validate phone number
      if (!this.validatePhoneNumber(phoneNumber)) {
        return {
          success: false,
          message: 'Invalid phone number. Please enter a valid 10-digit Indian mobile number.'
        };
      }

      const cleanedPhone = this.cleanPhoneNumber(phoneNumber);

      // Check cooldown
      const cooldownStatus = this.canResend(cleanedPhone);
      if (!cooldownStatus.canResend) {
        return {
          success: false,
          message: `Please wait ${cooldownStatus.remainingSeconds} seconds before requesting a new OTP.`,
          remainingSeconds: cooldownStatus.remainingSeconds
        };
      }

      // Use SMS AUTOGEN endpoint (NOT VOICE!)
      // Format: https://2factor.in/API/V1/{api_key}/SMS/91{phone}/AUTOGEN
      // The 91 prefix is required for Indian numbers
      const apiUrl = `${this.baseUrl}/${this.apiKey}/SMS/91${cleanedPhone}/AUTOGEN`;

      logger.info(`Sending SMS OTP to phone: ${cleanedPhone.substring(0, 4)}****${cleanedPhone.substring(8)}`);

      // Call 2Factor SMS OTP API
      const response = await axios.get(apiUrl, {
        timeout: 30000 // 30 second timeout
      });

      if (response.data && response.data.Status === 'Success') {
        // Store session ID for verification
        const sessionId = response.data.Details;
        
        this.otpStore.set(cleanedPhone, {
          sessionId,
          lastSentAt: Date.now(),
          expiresAt: Date.now() + this.otpExpiryMs,
          attempts: 0 // Track verification attempts
        });

        logger.info(`SMS OTP sent successfully to ${cleanedPhone.substring(0, 4)}****${cleanedPhone.substring(8)}, sessionId: ${sessionId}`);

        return {
          success: true,
          message: 'OTP sent successfully to your phone number via SMS.'
        };
      } else {
        logger.error('2Factor SMS API error:', response.data);
        return {
          success: false,
          message: response.data?.Details || 'Failed to send OTP. Please try again.'
        };
      }
    } catch (error) {
      logger.error('SMS OTP send error:', error.response?.data || error.message);
      
      // Handle specific 2Factor errors
      if (error.response?.data?.Status === 'Error') {
        return {
          success: false,
          message: error.response.data.Details || 'Failed to send OTP. Please try again.'
        };
      }

      return {
        success: false,
        message: 'Unable to send OTP at this time. Please try again later.'
      };
    }
  }

  /**
   * Verify OTP entered by user via 2Factor VERIFY3 API
   * @param {string} phoneNumber - Phone number that received OTP
   * @param {string} otp - OTP entered by user
   * @returns {Promise<Object>} - { success: boolean, message: string }
   */
  async verifyOTP(phoneNumber, otp) {
    try {
      // Validate inputs
      if (!this.validatePhoneNumber(phoneNumber)) {
        return {
          success: false,
          message: 'Invalid phone number.'
        };
      }

      if (!otp || !/^\d{6}$/.test(otp)) {
        return {
          success: false,
          message: 'Invalid OTP format. Please enter the 6-digit OTP received via SMS.'
        };
      }

      const cleanedPhone = this.cleanPhoneNumber(phoneNumber);

      // Get stored session
      const stored = this.otpStore.get(cleanedPhone);
      if (!stored || !stored.sessionId) {
        return {
          success: false,
          message: 'OTP session expired or not found. Please request a new OTP.'
        };
      }

      // Check if session has expired
      if (Date.now() > stored.expiresAt) {
        this.otpStore.delete(cleanedPhone);
        return {
          success: false,
          message: 'OTP has expired. Please request a new OTP.'
        };
      }

      // Check attempt limit (max 5 wrong attempts)
      if (stored.attempts >= 5) {
        this.otpStore.delete(cleanedPhone);
        return {
          success: false,
          message: 'Too many incorrect attempts. Please request a new OTP.'
        };
      }

      // Verify OTP via 2Factor /SMS/VERIFY/ API (as per document)
      const verifyUrl = `${this.baseUrl}/${this.apiKey}/SMS/VERIFY/${stored.sessionId}/${otp}`;
      
      const response = await axios.get(verifyUrl, {
        timeout: 30000
      });

      if (response.data && response.data.Status === 'Success' && response.data.Details === 'OTP Matched') {
        // Clear the stored session on successful verification
        this.otpStore.delete(cleanedPhone);
        
        logger.info(`OTP verified successfully for ${cleanedPhone.substring(0, 4)}****${cleanedPhone.substring(8)}`);

        return {
          success: true,
          message: 'OTP verified successfully.'
        };
      } else {
        // Increment attempt counter
        stored.attempts = (stored.attempts || 0) + 1;
        this.otpStore.set(cleanedPhone, stored);
        
        const remainingAttempts = 5 - stored.attempts;
        logger.warn(`OTP verification failed for ${cleanedPhone.substring(0, 4)}****${cleanedPhone.substring(8)}: ${remainingAttempts} attempts remaining.`);
        
        return {
          success: false,
          message: `Incorrect OTP. ${remainingAttempts} attempt${remainingAttempts !== 1 ? 's' : ''} remaining.`
        };
      }
    } catch (error) {
      logger.error('OTP verify error:', error.response?.data || error.message);
      
      // Handle 2Factor error response (wrong OTP)
      if (error.response?.data?.Status === 'Error') {
        const cleanedPhone = this.cleanPhoneNumber(phoneNumber);
        const stored = this.otpStore.get(cleanedPhone);
        
        if (stored) {
          stored.attempts = (stored.attempts || 0) + 1;
          this.otpStore.set(cleanedPhone, stored);
          const remainingAttempts = 5 - stored.attempts;
          
          if (remainingAttempts <= 0) {
            this.otpStore.delete(cleanedPhone);
            return {
              success: false,
              message: 'Too many incorrect attempts. Please request a new OTP.'
            };
          }
          
          return {
            success: false,
            message: `Incorrect OTP. ${remainingAttempts} attempt${remainingAttempts !== 1 ? 's' : ''} remaining.`
          };
        }
      }
      
      return {
        success: false,
        message: 'Unable to verify OTP at this time. Please try again.'
      };
    }
  }

  /**
   * Clean up expired entries from the store
   */
  cleanupExpiredEntries() {
    const now = Date.now();
    let cleanedCount = 0;

    for (const [phone, data] of this.otpStore.entries()) {
      if (now > data.expiresAt) {
        this.otpStore.delete(phone);
        cleanedCount++;
      }
    }

    if (cleanedCount > 0) {
      logger.debug(`Cleaned up ${cleanedCount} expired SMS OTP entries`);
    }
  }

  /**
   * Get cooldown status for a phone number (for API response)
   * @param {string} phoneNumber - Phone number to check
   * @returns {Object} - Cooldown status info
   */
  getCooldownStatus(phoneNumber) {
    const cleanedPhone = this.cleanPhoneNumber(phoneNumber);
    const status = this.canResend(cleanedPhone);
    
    return {
      canResend: status.canResend,
      remainingSeconds: status.remainingSeconds,
      cooldownPeriod: this.resendCooldownMs / 1000
    };
  }
}

// Export singleton instance
module.exports = new SMSOtpService();
